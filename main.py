# Глобальная цель - дорастить к первой ноде (элементарной) вторую. Визуалилизировать.
# Нужно в отдельном проектике поэкспериментировать с правилом, не выписывая
# громоздких слоэных структур данных.
# ЗАЧЕМ ЭТО НАДО: дальше мы в след.итерациях будем пытаться зациклить это правило.
# Если удастяся, это будет алгоритм обучения, в ходе которого вырастет селективная к лейблу структура (вин!)
# ПОЧЕМУ НУЖНА ОТДЕЛЬНАЯ ИТЕРАЦИЯ: потому что потребуется рад экспериментов с кодом,
# чтобы уточнить эвристику выбора параметров u_rad, sens_rad, Amin, Amax, без чего у нас не будет новых нод.

# ШАГ 1 выглядит так:
# хардокно прописываем параметры первого бинарного юнита - с-рад =0, радиус события 50, ю-рад =0.
# бегаем этм юнитом по изображениям (диверсе или три).
# собираем стату по всем управлениям из точки срабатывания
# счтитаем теоретическую предсказанное распрееделение для них
# считаем распределение эмпирическое
# считаем при каких упр. есть рили разница (и насколько значительна)
# там где значения разницы велики, называем управление характеристическим.
# Визуализируем наглядно характеристическкие.
# ВОЗМОЖНО:
# "ослабляем" параметры управленией до тих пор, пока она не перестанут быть характеричтическикми. Есть порог?
# при каком минимальном размере выьорки срабатываний характеристики становятся достаточно четкими?
# В будущем реализуем функционал вида "на данной ноде накопилось достаточно активаций, чтоб
# такую-то управление признать характеристическим"

# ШАГ 2 "НОДА Б из характеристики":
# пробуем из какой-то характрестики слепить кандидата на вторую ноду Б.

# ШАГ 3 "НОДА Б из события на эталоне":
# берем конкретную эталонную тройку, на которой в данной точке сработала нода А.
# Для ноды А у нас уже имеются все распределения: часть характеричтисчны, а остальные совпадают с рассчетными
# из более низких стат. даннух.
# ЭВРИСТИКА: на данной тройке в открестостях этой точки
# ищем что-то редкое (можно наугад, назовем это событие Б). Собираем статистику, где Б активируется
# с минимальными ппоправками, пытаемся сделать из Б бинарный юнит такой, что h(АБ)>>h(А)

#  --------------------------------------------------------------- #
# ИДЕИ:
# 1. эвристика ослабления кандидата:
# если кандидат Б это строгое нечто (то есть малые радиусы все), то сработавших Б будет очень мало.
# Малой выорки будет досаточно, чтобы потдвердить закокомерность, только если на характеристиках А вызобувтся
# очень редкие события . если две разных редкости случились одновременно (очень теплое и оечн мягкое), то
# мы управляем одной редкостью и смотрим менсяется ли вторая.
#2 для данной А ищем такое Б что h(A) + h(b) << h(AB)


from logger import *
from find_candidates import *

def make_exp0():
    logger = HtmlLogger("it14_ex0")
    cf = CandidatesFinder(etalon=224, event_diameter=15, sensor_field_radius=0)
    logger.add_text("vary sens_field_radius_________________________________________________________________")
    cf.get_simplest_candidates(radius=2, logger=logger, sens_field_radius=0, u_radius=0)

    logger.close()

if __name__ == "__main__":
    make_exp0()


